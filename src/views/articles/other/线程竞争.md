# 线程竞争（Thread Contention）

## 简介

也称为竞争条件（Race Condition），是指多个线程在同时访问和修改共享资源时，可能导致不可预期的行为或错误。由于线程调度的不可预测性，这些线程在运行时的执行顺序可能会有所不同，从而导致数据的不一致性或其他问题。

## 线程竞争的典型问题

- **数据不一致性**：多个线程同时读写共享数据，可能导致数据状态不一致。例如，两个线程同时修改一个计数器变量，最终结果可能不是预期的增量值。
- **死锁（Deadlock）**：多个线程互相等待对方释放资源，导致程序无法继续执行。
- **活锁（Livelock）**：多个线程频繁改变状态或相互让步，导致系统无法前进，但线程本身并未阻塞。
- **资源饥饿（Resource Starvation）**：某些线程长时间无法获得所需资源，导致其无法执行。

## 线程竞争的解决方法

- **锁机制**：使用**互斥锁（Mutex）**、**读写锁（Read-Write Lock）**等同步原语来确保同一时刻只有一个线程能访问共享资源。例如，Java中的synchronized关键字和ReentrantLock类。
- **原子操作**：确保某些操作在执行过程中不会被中断。许多编程语言提供了原子类，如Java中的AtomicInteger。
- **线程局部存储（Thread Local Storage）**：为每个线程提供独立的存储，避免共享数据。
- **不可变对象**：使用不可变对象，避免对象状态在创建后被修改。
- **消息传递模型**：使用消息传递而非共享内存，避免直接共享数据。例如，使用队列（Queue）在生产者-消费者模式中传递消息。

## 示例

假设我们有一个简单的计数器程序，两个线程同时对其进行递增操作：

```java
public class Counter {
    private int count = 0;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }

    public static void main(String[] args) {
        Counter counter = new Counter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final count: " + counter.getCount());
    }
}
```

在这个例子中，由于increment方法不是线程安全的，最终的计数结果可能不是预期的2000。

解决办法，使用同步

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

通过将`increment`方法声明为`synchronized`，确保每次只有一个线程能执行该方法，从而避免线程竞争导致的数据不一致问题。

线程竞争是并发编程中的常见问题，理解并合理使用同步机制和并发工具可以有效避免相关问题，确保程序的正确性和稳定性。
