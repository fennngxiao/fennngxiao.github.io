# 当你在浏览器地址栏输入一个URL后回车，将会发生的事情？

### 1、浏览器向DNS服务器查找输入URL对应的IP地址。

我们输入的网址(域名)是IP地址的一个别名， 在一个DNS内，一个域名对应一个IP地址。域名系统(DNS) 的工作就是将域名与它的IP地址对应起来。DNS是分布式的，同时也是具有层级关系的。

### 2、DNS服务器返回网站的IP地址。

递归寻找DNS服务器
一个域名服务器虽然只记录一个小的子网内的主机名和IP地址， 但所有的域名服务器联合起来工作，就能将全网内的域名与它们的IP地址对应起来。 这也就意味着，如果一个域名服务器无法找到某个请求域名所对应的IP地址， 它就会向其它的域名服务器发出请求进行寻找。

### 3、浏览器根据IP地址与目标web服务器在80端口上建立TCP连接

关于TCP协议

#### 3.1、建立连接

三次握手

1:客户端的协议栈向服务端发送 SYN 包，并告诉服务端当前发送序列号 j（ISN），客户端进入 SYNC_SENT 状态；

2:服务端的协议栈收到这个 SYN 包之后，检查 SYN 合法性，然后会创建一个半连接的对象，将其加入到内核的「 SYN 队列」。接着给客户端发送 SYN+ACK 包，确认序列号为 j+1，表示对 SYN 包 j 的确认，服务端序列号为 k（ISN），服务端进入 SYNC_RCVD 状态，这时处于半连接状态；

3:客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回（或者监听的 socket 有读事件），表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务端的 SYN 包进行应答，确认序号为 k+1；

4:当服务器端收到这个 ACK 包的时候，从「 SYN 队列」取出对应的半连接对象，然后创建一个新的全连接对象放入到「 Accept 队列」，这个时候服务端到客户端的单向连接也建立成功，服务端也进入 ESTABLISHED 状态；服务端调用 accept 函数，从「Accept 队列」中取出全连接对象，创建一个新的用于双向通信的 sockfd。第三次握手是可以携带数据的，前两次握手是不可以携带数据的。

#### 3.2、关闭连接

四次挥手

1:「主动方」想要关闭连接，会发送一个 FIN 报文，序号 m，之后「主动方」进入 FIN_WAIT_1 状态，仅仅表示「主动方」不再发送数据了但是还能接收数据；
2:「被动方」收到 FIN 报文后，就向「主动方」发送 ACK m + 1 应答报文，并向接收缓冲区写入一个文件结束符 EOF，排在未读数据之后，然后「被动方」进入 CLOSE_WAIT 状态；
3:「主动方」收到「被动方」的 ACK 应答报文之后进入 FIN_WAIT_2 状态；
4:「被动方」把数据发送完并且调用 read 函数读到 EOF 后，调用 close 函数，也向「主动方」发送 FIN 报文，序号 n，然后「被动方」进入 LAST_ACK 状态。如果发现服务器有大量 CLOSE_WAIT 状态的连接，需要排查代码中是否有 bug 导致 read 到 EOF 后没有调用 close 函数；
5:「主动方」收到「被动方」的 FIN 报文后，回一个 ACK n + 1 应答报文，然后进入 TIME_WAIT 状态；
6:「被动方」收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此「被动方」已经完成连接的关闭；
7:「主动方」在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此「主动方」也完成连接的关闭。

从上面过程可知，「被动方」通常需要等待发送和处理完数据，所以「被动方」的 FIN 和 ACK 一般都会分开发送，因此是需要四次挥手。但是在特定情况下（「被动方」在收到第一次握手后，没有要处理的数据了），四次挥手是可以变成三次挥手的。

「被动方」才有 CLOSE_WAIT 状态，如果「被动方」因为代码 bug 没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，也就无法使得 CLOSE_WAIT 状态转变为 LAST_ACK 状态。TCP 的连接信息是由内核维护的，当进程崩溃后，内核回收该进程的所有 TCP 连接，内核会与对端完成四次挥手。

### 4、浏览器获取请求页面的html代码。

4.1:向目标服务器发送http请求
4.2:web服务器接收请求后处理
4.3:web服务器返回相应的结果【无效、重定向、正确页面等】
4.5:浏览器接收返回的http内容

### 5、浏览器在显示窗口内渲染HTML。

5.1:开始解析html文件，当然是自上而下，先是头部，后是body
5.2:当解析到头部css外部链接时，同步去下载，如果遇到外部js链接也是下载【 不过js链接不建议放在头部，因为耽误页面第一展现时间 】
5.3:接着解析body部分，边解析边开始生成对应的DOM树，同时等待css文件下载
5.4:一旦css文件下载完毕，那么就同步去用已经生成的DOM节点+CSS去生成渲染树
5.5:渲染树一旦有结构模型了，接着就会同步去计算渲染树节点的布局位置
5.6:一旦计算出来渲染的坐标后，又同步去开始渲染
5.7:进行过程中如果遇到图片则跳过去渲染下面内容，等待图片下载成功后会返回来在渲染原来图片的位置
5.8:如果渲染过程中出现js代码调整DOM树机构的情况，也会再次重新来过，从修改DOM那步开始
5.9:最终所有节点和资源都会渲染完成
5.10:渲染完成后开始页面的onload事件
5.11:自此整个页面load完成

### 6、窗口关闭时，浏览器终止与服务器的连接。
