[
	{
		"fileName": "box-shadow像素动画",
		"fileType": "vue",
		"path": "src/views/articles/css/box-shadow像素动画.vue",
		"category": "css",
		"id": "css-box-shadow像素动画",
		"content": "box-shadow像素动画"
	},
	{
		"fileName": "box-shadow动画eyes",
		"fileType": "vue",
		"path": "src/views/articles/css/box-shadow动画eyes.vue",
		"category": "css",
		"id": "css-box-shadow动画eyes",
		"content": "box-shadow动画eyes"
	},
	{
		"fileName": "css icon",
		"fileType": "vue",
		"path": "src/views/articles/css/css icon.vue",
		"category": "css",
		"id": "css-css icon",
		"content": "css icon"
	},
	{
		"fileName": "mix-blend-mode CSS效果",
		"fileType": "vue",
		"path": "src/views/articles/css/mix-blend-mode CSS效果.vue",
		"category": "css",
		"id": "css-mix-blend-mode CSS效果",
		"content": "mix-blend-mode CSS效果"
	},
	{
		"fileName": "常用设计参考",
		"fileType": "md",
		"path": "src/views/articles/design/常用设计参考.md",
		"category": "design",
		"id": "design-常用设计参考",
		"content": " 常用设计资源及效果参考地址 一、UI1.  花瓣: [https://huaban.com/](https://huaban.com/)2.  Dribbble: [https://dribbble.com/](https://dribbble.com/)3.  站酷: [https://www.zcool.com.cn/](https://www.zcool.com.cn/)4.  SketchRepo: [https://sketchrepo.com/](https://sketchrepo.com/) 二、摄影/图片/壁纸1.  Unsplash: [https://unsplash.com/](https://unsplash.com/)   ![Unsplash](./imgs/design/1691700221243_.pic_hd.jpg)2.  Pexels: [https://www.pexels.com/zh-cn/](https://www.pexels.com/zh-cn/)   ![Unsplash](./imgs/design/1681700221226_.pic_hd.jpg)3.  Booooooom: [https://www.booooooom.com/](https://www.booooooom.com/)   ![Unsplash](./imgs/design/1671700221210_.pic_hd.jpg)4.  Trendlist: [https://www.trendlist.org/](https://www.trendlist.org/)   ![Unsplash](./imgs/design/1661700221111_.pic_hd.jpg)5.  Wallhaven: [https://wallhaven.cc](https://wallhaven.cc/search?q=&page=2)   ![Unsplash](./imgs/design/WechatIMG170.png)6.  Wallpaper: [https://wall.alphacoders.com/](https://wall.alphacoders.com/by_category.php?id=10&name=Nature+Wallpapers)   ![Unsplash](./imgs/design/WechatIMG171.png)7.  4Kwallpapers: [https://4kwallpapers.com/](https://4kwallpapers.com/)   ![Unsplash](./imgs/design/WechatIMG172.png)8.  图虫: [https://tuchong.com/](https://tuchong.com/)   ![Unsplash](./imgs/design/WechatIMG178.png) 三、效果参考1.  WebdesignClip: [http://www.webdesignclip.com/](http://www.webdesignclip.com/)   ![Unsplash](./imgs/design/WechatIMG173.png)2.  site inspire: [https://www.siteinspire.com/websites](https://www.siteinspire.com/websites)   ![Unsplash](./imgs/design/WechatIMG177.png)3.  CODEPEN: [https://codepen.io/](https://codepen.io/)   ![Unsplash](./imgs/design/WechatIMG174.png)4.  Kieran Baybutt Website [https://kieranbaybutt.com/](https://kieranbaybutt.com/)   ![Unsplash](./imgs/design/WechatIMG175.png)5.  Thomas Website [https://thomasaufresne.com/](https://thomasaufresne.com/)   ![Unsplash](./imgs/design/WechatIMG176.png) 四、其他1.  设计达人博客: [https://www.shejidaren.com/](https://www.shejidaren.com/)"
	},
	{
		"fileName": "a标签target _blank的报错",
		"fileType": "md",
		"path": "src/views/articles/html/a标签target _blank的报错.md",
		"category": "html",
		"id": "html-a标签target _blank的报错",
		"content": " 关于 a标签属性target=\"\\_blank\"时，ESlint检测报错问题相关当直接写一个a标签并添加target=\"\\_blank\"属性时，ESlint检测会报错，如图所示：![Alt text](./imgs/html/a标签target=_blank的报错.png){{{width=\"auto\" height=\"100\"}}}这里指出在较旧的浏览器当中会存在安全风险，需加上**rel=\"noreferrer\"**当使用**target=\"\\_blank\"**打开一个新的标签页时，新页面的window对象上有一个属性“opener”,它指向的是前一个页面的window对象，此时，新打开的页面就可以控制前一个页面。甚至可以通过**window.opener.location.replace**使前一个页面跳转至其他的页面。为了避免上述安全漏洞的发生，我们就需要在a标签上添加**rel=\"noopener noreferrer\"**属性，此时新开启的标签页当中的windwo.opener就置为**null**了。"
	},
	{
		"fileName": "JS 属性描述符",
		"fileType": "md",
		"path": "src/views/articles/js/JS 属性描述符.md",
		"category": "js",
		"id": "js-JS 属性描述符",
		"content": " JavaScript中支持6种属性描述符: configurable:设为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。 enumerable:enumerable控制对象属性是否可枚举在JavaScript中，对象的属性有可枚举和不可枚举之分，它是由对象属性描述符enumerable决定的，当设置为true的时候该属性才会出现在对象的枚举属性中。如果该属性是可枚举性的那么这个属性就能被for…in查找遍历到 value:该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认值undefined。 writable:设置为true的时候，value才能被赋值运算符（=）改变。 get:属性的 getter 函数。当访问该属性时，才会调用此函数，执行时不传入任何参数，但是会传入 this 对象。该函数的返回值会被用作属性的值。默认值undefined。 set:属性的 setter 函数。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认值undefined。 枚举属性相关方法 Object.defineProperty(obj, prop, descriptor)通过Object.defineProperty()定义的属性，enumerable，configurable，writable这几个值默认为falsejavascriptObject.defineProperty({}, 'key', {  enumerable: false,  configurable: false,  writable: false,  value: 'static'})直接为对象动态添加属性，enumerable，configurable，writable这几个值默认为true（当属性值为true时 enumerable/可枚举，configurable/描述符控制，属性可被删除，writable/value可被赋值改变）javascriptconst obj = {}obj.name = 'Sean' Object.getOwnPropertyNames()获取对象自身所有的属性键名（自有属性），包括可枚举和不可枚举的属性，但不包括使用 symbol 值作为名称的属性。 Object.keys()获取对象自身的可枚举属性键名，返回键名数组。 Object.prototype.propertyIsEnumerable()判断对象实例obj自身的属性是否为可枚举, 属性名，可以是字符串或 Symbol。 for...in遍历对象自身的和原型链上的可枚举的属性。可配合Object.hasOwn / Object.prototype.hasOwnProperty() 只获取自身可枚举属性 Object.hasOwn旨在取代 Object.prototype.hasOwnProperty()Object.hasOwn(target, \"prop\"); Object.values()获取对象自身的可枚举属性的值，返回值数组。 Object.entries()获取对象自身的可枚举属性的键值对，每个键值对以数组的形式存储，返回键值对数组集。for of 遍历对象javascriptfor (const [key, value] of Object.entries(object1)) {console.log(${key}: ${value});}// \"a: somestring\"// \"b: 42\"以上几个方法除了for...in外其他的方法都无法遍历到原型链的属性。 Reflect.ownKeys()获取对象自身所有的属性键名，包括Symbol类型属性 Object.getOwnPropertySymbols()获取对象自身Symbol类型属性，Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。"
	},
	{
		"fileName": "JSON.stringfy的参数",
		"fileType": "md",
		"path": "src/views/articles/js/JSON.stringfy的参数.md",
		"category": "js",
		"id": "js-JSON.stringfy的参数",
		"content": " JSON.stringify 和它的三个参数 replacer: array | function- 当第二个参数为Array时，包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中- 当第二个参数为函数时，被序列化的值的每个属性都会经过该函数的转换和处理  若该函数返回值是undefined，那么对应的属性不会被序列化，如果返回其他的值，那么用返回的值替代原来的值进行序列化javascript function(key, value) { return newValue } space: number- stringify可以通过第三个参数来控制序列化的内容的空格缩进 例如2/4（2个空格或者4个空格） 注意点： JSON.stringify 无法转化的值 1、被转换值中有 NaN 和 Infinity时 会被转化为nulljavascriptlet myObj = {  name: 'xxx',  age: Infinity,  money: NaN}console.log(JSON.stringify(myObj))// {\"name\":\"xxx\",\"age\":null,\"money\":null}JSON.stringify([NaN, Infinity])// [null,null] 2、被转换值中有 undefined、任意的函数以及 symbol 值- 数组,undefined、任意的函数以及symbol值在序列化的过程中会被转换成 nulljavascriptJSON.stringify([undefined, function () { }, Symbol(\"\")]);// '[null,null,null]'- 非数组,undefined、任意的函数以及symbol值在序列化的过程中会被忽略JSON.stringify({ x: undefined, y: function () { }, z: Symbol(\"\") });// '{}' 3、循环引用 会报错 4、含有不可枚举的属性值时javascriptlet personObj = Object.create(null, {  name: { value: 'FennngXiao', enumerable: false },  year: { value: '2021', enumerable: true }})console.log(JSON.stringify(personObj)) // {\"year\":\"2021\"}"
	},
	{
		"fileName": "Object.defineProperty",
		"fileType": "md",
		"path": "src/views/articles/js/Object.defineProperty.md",
		"category": "js",
		"id": "js-Object.defineProperty",
		"content": " Object.defineProperty 数据劫持方式 语法Object.defineProperty(obj,prop,descriptor) 参数- obj: 目标对象- prop: 需要定义的属性或方法的名称- descriptor: 目标属性所拥有的特性 可供定义的特性列表- value: 属性的值- writable: 如果为false，属性的值就不能被重写。- get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。- set: 一旦目标属性被赋值，就会调回此方法。- configurable: 如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。- enumerable: 是否能在for...in循环中遍历出来或在Object.keys中列举出来。javascriptObject.defineProperty(data, key, {  enumerable: true, // 是否能在for...in循环中遍历出来或在Object.keys中列举出来。  configurable: true, // false，不可修改、删除目标属性或修改属性性以下特性  get: function () {    console.log('get')  },  set: function () {    console.log('监听到数据发生了变化')  }})"
	},
	{
		"fileName": "DOM",
		"fileType": "md",
		"path": "src/views/articles/js/Web API/DOM.md",
		"category": "Web API",
		"id": "Web API-DOM",
		"content": " DOM DOM结构——两个节点之间可能存在哪些关系以及如何在节点之间任意移动同级（在前，在后）、父子、包含移动方法：|名称 | 方法 || ---- | ---- || 添加 | appendChild || 删除 | removeChild || 替换 | replaceChild || 插入 | insertBefore |一个节点不能同时位于文档的两个点中。因此，如果被插入节点已经有父节点，则首先删除该节点，然后将其插入到新位置若要保留已在文档中的被插入节点，在将该节点追加到新父节点之前，可以使用 Node.cloneNode() 复制节点。注意，使用 cloneNode() 创建的节点副本不会自动与原始节点保持同步。"
	},
	{
		"fileName": "web work",
		"fileType": "md",
		"path": "src/views/articles/js/Web API/web work.md",
		"category": "Web API",
		"id": "Web API-web work",
		"content": " Web Workers 简介Web Worker是HTML5引入的一种技术，用于在后台线程中运行JavaScript代码，以避免阻塞用户界面的操作。它可以帮助开发者在不影响主线程（UI线程）响应速度的情况下，执行复杂和耗时的任务，从而提升Web应用的性能和响应速度。 关键特性- 独立线程：Web Worker运行在与主线程分离的独立线程中，不会影响主线程的性能和UI响应。- DOM访问限制：Web Worker不能直接访问DOM元素，以避免[线程竞争](https://fennngxiao.github.io//articles/mdPage/other-线程竞争)问题。  Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。- 消息传递：主线程和Worker线程之间通过消息传递机制进行通信，使用postMessage方法发送消息，onmessage事件接收消息。- 同源限制：Web Worker受到同源策略的限制，分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源，这样可确保安全性。- 脚本限制：Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。- 文件限制：Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。Worker 内部如果要加载其他脚本，可以通过专有方法importScripts方法加载外部脚本文件。 使用示例 创建和启动Web Worker首先，在主线程中创建一个Worker对象，指定要运行的脚本文件：js// 主线程代码if (window.Worker) {  const myWorker = new Worker('worker.js')  myWorker.postMessage('Hello, Worker!') // 向Worker发送消息  myWorker.onmessage = function (e) {    console.log('主线程接收到消息: ' + e.data)  }  myWorker.onerror = function (e) {    console.error('Worker出错: ', e)  }} else {  console.log('你的浏览器不支持Web Worker.')} Worker线程脚本在独立的Worker脚本文件中，处理接收到的消息并返回结果：js// worker.jsonmessage = function (e) {  console.log('Worker接收到消息: ' + e.data)  let result = e.data + ' (from Worker)'  postMessage(result) // 向主线程发送消息} 终止 workerjsmyWorker.terminate() 典型应用场景- 复杂计算：例如大量数据处理、科学计算、图像处理等耗时任务。- 实时数据处理：如WebSocket数据流、文件读写等需要后台处理的实时任务。- 动画和游戏：在不影响主线程渲染的情况下，处理复杂的游戏逻辑和物理运算。 注意事项- 同源限制：分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。- 线程开销：创建和销毁Worker是有开销的，适合长期任务。- 通信开销：消息传递涉及序列化和反序列化，频繁通信可能影响性能。- 浏览器支持：现代浏览器普遍支持Web Worker，但在使用前应检查兼容性。通过Web Worker，开发者可以在Web应用中实现更高效的并行处理，提升用户体验。"
	},
	{
		"fileName": "节点关系比较",
		"fileType": "md",
		"path": "src/views/articles/js/Web API/节点关系比较.md",
		"category": "Web API",
		"id": "Web API-节点关系比较",
		"content": " Node.compareDocumentPosition 比较当前节点与任意文档中的另一个节点的位置关系，该方法用于确定节点间的关系，返回一个表示该关系的位掩码node.compareDocumentPosition( otherNode )位掩码含义表：| 常量名 | 十进制值 | 含义 || ---- | ---- | ---- || DOCUMENT_POSITION_DISCONNECTED | 0 | 两个节点相同 || DOCUMENT_POSITION_DISCONNECTED | 1 | 不在同一文档中 || DOCUMENT_POSITION_PRECEDING | 2 | otherNode 在 node 之前 || DOCUMENT_POSITION_FOLLOWING | 4 | otherNode 在 node 之后 || DOCUMENT_POSITION_CONTAINS | 8 | otherNode 包含 node || DOCUMENT_POSITION_CONTAINED_BY | 16 | otherNode 被 node 包含 || DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | 32 | 浏览器的私有用途 | Node.isSameNode 判断两个节点是否是相同的节点，即指向同一个对象 Node.isEqualNode 可以判断两个节点是否相等，多数时候的比较是根据节点的类型来的。这两个方法都接受一个节点参数，并在传入节点与引用节点相同或相等时返回true所谓相同(same)，指的是两个节点引用的是同一个对象所谓相等(equal)，指的是两个节点是相同的类型，具有相等的属性(nodeName、nodeValue等等)，而且它们的attributes和childNodes属性也相等(相同位置包含相同的值)[注意]firefox不支持isSameNode()方法，而IE8-浏览器两个方法都不支持javascriptvar div1 = document.createElement('div')div1.setAttribute('title', 'test')var div2 = document.createElement('div')div2.setAttribute('title', 'test')console.log(div1.isSameNode(div1)) //trueconsole.log(div1.isEqualNode(div2)) //trueconsole.log(div1.isSameNode(div2)) //false"
	},
	{
		"fileName": "首屏加载时间获取",
		"fileType": "md",
		"path": "src/views/articles/js/Web API/首屏加载时间获取.md",
		"category": "Web API",
		"id": "Web API-首屏加载时间获取",
		"content": " 首屏加载时间获取 PerformanceNavigationTimingjavascriptconst nav = performance.getEntriesByType('navigation')[0] // PerformanceNavigationTimingconsole.log(nav.duration) // ms 首屏加载时间function getPerformanceTiming() {  const performance = window.performance  if (!performance) return  const nav = performance.getEntriesByType('navigation')[0]  const t = performance.timing  const times = {}  //【重要】页面加载完成的时间, 即用户等待页面可用的时间  times.loadPage = nav.duration // nav.loadEventEnd - nav.startTime  //【重要】解析 DOM 树结构的时间  times.domReady = nav.domComplete - nav.responseEnd  //【重要】重定向的时间  //【注意】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com  times.redirect = nav.redirectEnd - nav.redirectStart  //【重要】DNS 查询时间  //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？  // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)  times.lookupDomain = nav.domainLookupEnd - nav.domainLookupStart  //【重要】读取页面第一个字节的时间  times.ttfb = nav.responseStart - nav.navigationStart  //【重要】内容加载完成的时间  //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？  times.request = nav.responseEnd - nav.requestStart  //【重要】执行 onload 回调函数的时间  //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？  times.loadEvent = nav.loadEventEnd - nav.loadEventStart  // DNS 缓存时间  times.appcache = nav.domainLookupStart - nav.fetchStart  // 卸载页面的时间  times.unloadEvent = nav.unloadEventEnd - nav.unloadEventStart  // TCP 建立连接完成握手的时间  times.connect = nav.connectEnd - nav.connectStart  return times}[转自掘金](https://juejin.cn/post/6998505619682492429)"
	},
	{
		"fileName": "Promise函数判断",
		"fileType": "md",
		"path": "src/views/articles/js/常用业务方法/Promise函数判断.md",
		"category": "常用业务方法",
		"id": "常用业务方法-Promise函数判断",
		"content": " 判断当前函数是否是Promise简单粗暴的做法是可以检查该对象是否具有 then 方法和 catch 方法，这是 Promise 对象的特征 方法一：使用 `instanceof`最直接的方法是使用 `instanceof` 操作符：jsfunction isPromise(value) {  return value instanceof Promise} 方法二：检查是否有 `then` 方法可以检查对象是否具有 `then` 方法，这通常也能识别出一个 Promise：jsfunction isPromise(value) {  return value !== null && typeof value === 'object' && typeof value.then === 'function'} 严谨延伸：结合 `then` 和 `catch` 方法更加严格的判断方式是同时检查 then 和 catch 方法：jsfunction isPromise(value) {  return (    value !== null &&    typeof value === 'object' &&    typeof value.then === 'function' &&    typeof value.catch === 'function'  )} 总结结合以上，我们可以得到一个非常严谨的判断方法jsfunction isPromise(value) {  return (    value !== null &&    typeof value === 'object' &&    typeof value.then === 'function' &&    typeof value.catch === 'function' &&    value instanceof Promise  )}"
	},
	{
		"fileName": "判断当前设备",
		"fileType": "md",
		"path": "src/views/articles/js/常用业务方法/判断当前设备.md",
		"category": "常用业务方法",
		"id": "常用业务方法-判断当前设备",
		"content": " 判断当前设备是否是移动端或PCjavascriptif (  window.navigator.userAgent.match(    /(phone|pad|pod|iPhone|iPad|iPod|ios|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i  )) {  return 'mobile'} else {  // 此时为null  return 'pc'}"
	},
	{
		"fileName": "常用正则",
		"fileType": "md",
		"path": "src/views/articles/js/常用业务方法/常用正则.md",
		"category": "常用业务方法",
		"id": "常用业务方法-常用正则",
		"content": " 一、校验数字的表达式 1. 数字：    ^[0-9]*$ 2. n位的数字：    ^\\d{n}$ 3. 至少n位的数字：    ^\\d{n,}$ 4. m-n位的数字：    ^\\d{m,n}$ 5. 零和非零开头的数字：    ^(0|[1-9][0-9]*)$ 6. 非零开头的最多带两位小数的数字：    ^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7. 带1-2位小数的正数或负数：    ^(\\-)?\\d+(\\.\\d{1,2})?$ 8. 正数、负数、和小数：    ^(\\-|\\+)?\\d+(\\.\\d+)?$ 9. 有两位小数的正实数：    ^[0-9]+(.[0-9]{2})?$ 10. 有1~3位小数的正实数：    ^[0-9]+(.[0-9]{1,3})?$ 11. 非零的正整数：    ^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 12. 非零的负整数：    ^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 13. 非负整数：    ^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：    ^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：    ^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：    ^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：    ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：    ^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：    ^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：    ^[\\u4e00-\\u9fa5]{1,}$ 2. 英文和数字：    ^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3. 长度为3-20的所有字符：    ^.{3,20}$ 4. 由26个英文字母组成的字符串：    ^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：    ^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：    ^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：    ^[A-Za-z0-9]+$ 8. 由数字、26个英文字母或者下划线组成的字符串：    ^\\w+$ 或 ^\\w{3,20}$ 9. 中文、英文、数字包括下划线：    ^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：    ^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11. 可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+ 12 禁止输入含有~的字符：    [^~\\x22]+ 三、其他 1. 车牌号 不包含IO    普通车牌：    /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/    新能源（含普通）：    /^([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[a-zA-Z](([DF]((?![IO])[a-zA-Z0-9](?![IO]))[0-9]{4})|([0-9]{5}[DF]))|[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1})$/ 2. 身份证    解析说明：    地区： ([1-6][1-9]|50)\\d{4}  // 补充重庆地区50    年的前两位： (18|19|20)       // 1800-2099    年的后两位： \\d{2}    月份：((0[1-9])|10|11|12)    天数： (([0-2][1-9])|10|20|30|31) // 闰年不能禁止29+    三位顺序码： \\d{3}    校验码： [0-9Xx]    18位：    /^([1-6][1-9]|50)\\d{4}(18|19|20)\\d{2}((0[1-9])|10|11|12)(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/    15位：    /^[1-9]\\d{5}\\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d{2}[0-9Xx]$/    身份证后6位：    /^(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/ 3.邮政编码    /^[1-9]\\d{5}$/ 4. 手机号    /^1[3-9][0-9]{9}$/"
	},
	{
		"fileName": "提取固定字符之间的字符串",
		"fileType": "md",
		"path": "src/views/articles/js/常用业务方法/提取固定字符之间的字符串.md",
		"category": "常用业务方法",
		"id": "常用业务方法-提取固定字符之间的字符串",
		"content": " 利用正则表达式提取固定字符之间的字符串.mdjavascript// 转义影响正则的字符function encodeReg(source) {  return String(source).replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1')}// 提取固定字符之间的字符串function getInnerString(source, prefix, postfix) {  var regexp = new RegExp(encodeReg(prefix) + '.+' + encodeReg(postfix), 'gi')  var matches = String(source).match(regexp)  var formatedMatches = matches.map((value) => {    return value.replace(prefix, '').replace(postfix, '')  })  return formatedMatches}// USEvar str = '123abcd456'getInnerString(str, '123', '456') // ['abcd']var str2 = '老总不在办公室，有事请留言给李秘书'getInnerString(str2, '有事请留言给', '') // ['李秘书']"
	},
	{
		"fileName": "数字加千分位",
		"fileType": "md",
		"path": "src/views/articles/js/常用业务方法/数字加千分位.md",
		"category": "常用业务方法",
		"id": "常用业务方法-数字加千分位",
		"content": " 数字增加千分位符号方法javascript// 方法一function format1(number) {  return number && number.replace(/(?!^)(?=(\\d{3})+\\.)/g, ',')}// 方法二function format2(number) {  return Intl.NumberFormat().format(number)}// 方法三function format3(number) {  return number.toLocaleString('en')}"
	},
	{
		"fileName": "数字汉字金额转换",
		"fileType": "md",
		"path": "src/views/articles/js/常用业务方法/数字汉字金额转换.md",
		"category": "常用业务方法",
		"id": "常用业务方法-数字汉字金额转换",
		"content": " 利用正则表达式提取固定字符之间的字符串javascriptexport const convertCurrency = (money) => {  // 汉字的数字  var cnNums = new Array('零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖')  // 基本单位  var cnIntRadice = new Array('', '拾', '佰', '仟')  // 对应整数部分扩展单位  var cnIntUnits = new Array('', '万', '亿', '兆')  // 对应小数部分单位  var cnDecUnits = new Array('角', '分', '毫', '厘')  // 整数金额时后面跟的字符  var cnInteger = '整'  // 整型完以后的单位  var cnIntLast = '元'  // 最大处理的数字  var maxNum = 999999999999999.9999  // 金额整数部分  var integerNum  // 金额小数部分  var decimalNum  // 输出的中文金额字符串  var chineseStr = ''  // 分离金额后用的数组，预定义  var parts  if (money == '') {    return ''  }  money = parseFloat(money)  if (money >= maxNum) {    // 超出最大处理数字    return ''  }  if (money == 0) {    chineseStr = cnNums[0] + cnIntLast + cnInteger    return chineseStr  }  // 转换为字符串  money = money.toString()  if (money.indexOf('.') == -1) {    integerNum = money    decimalNum = ''  } else {    parts = money.split('.')    integerNum = parts[0]    decimalNum = parts[1].substr(0, 4)  }  // 获取整型部分转换  if (parseInt(integerNum, 10) > 0) {    var zeroCount = 0    var IntLen = integerNum.length    for (var i = 0; i < IntLen; i++) {      var n = integerNum.substr(i, 1)      var p = IntLen - i - 1      var q = p / 4      var m = p % 4      if (n == '0') {        zeroCount++      } else {        if (zeroCount > 0) {          chineseStr += cnNums[0]        }        // 归零        zeroCount = 0        chineseStr += cnNums[parseInt(n)] + cnIntRadice[m]      }      if (m == 0 && zeroCount < 4) {        chineseStr += cnIntUnits[q]      }    }    chineseStr += cnIntLast  }  // 小数部分  if (decimalNum != '') {    var decLen = decimalNum.length    for (var i = 0; i < decLen; i++) {      var n = decimalNum.substr(i, 1)      if (n != '0') {        chineseStr += cnNums[Number(n)] + cnDecUnits[i]      }    }  }  if (chineseStr == '') {    chineseStr += cnNums[0] + cnIntLast + cnInteger  } else if (decimalNum == '') {    chineseStr += cnInteger  }  return chineseStr}"
	},
	{
		"fileName": "正则获取地址栏参数",
		"fileType": "md",
		"path": "src/views/articles/js/常用业务方法/正则获取地址栏参数.md",
		"category": "常用业务方法",
		"id": "常用业务方法-正则获取地址栏参数",
		"content": " 正则获取地址栏参数javascriptfunction GetQueryString(name) {  var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)')  var r = window.location.search.substr(1).match(reg)  if (r != null) return unescape(r[2])  return null}// 存在hash时function GetQueryString(name) {  var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)')  var r = window.location.hash.substr(location.hash.indexOf('?') + 1).match(reg)  if (r != null) return unescape(r[2])  return null}"
	},
	{
		"fileName": "登录密码是否需要加密",
		"fileType": "md",
		"path": "src/views/articles/js/登录密码是否需要加密.md",
		"category": "js",
		"id": "js-登录密码是否需要加密",
		"content": " 登录密码是否需要加密/混淆 https 情况下明文：传输层安全协议TLS 是可以保证我们和服务器端传输的安全性的例如github等加密混淆：例如淘宝、知乎 结论如果是开放生态，像Github这样，API公开，鼓励各种第三方客户端，那前端就没必要加密，如果是闭源生态，关键部分做一下前端代码的加密混淆，可以防止三方入口的伪装等 如果是http 或是 本地记住密码功能，那么还是需要对密码进行加密通常的加密方式分为两种：对称加密：采用对称密码编码技术，加/解密使用相同密钥进行，效率较高。非对称加密：基于密钥交换协议，拥有公开密钥和私有密钥，使用公钥加密后需使用对应私钥才能进行解密。 对称加密（Symmetric Cryptography）对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。 非对称加密（Asymmetric Cryptography）非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的其中一个进行加密，而解密则需要另一个密钥。 对称加密DES实现方式 (使用crypto-js)javascriptvar CryptoJS = require('crypto-js')const secretKey = 'YourCustomSalt'// 加密var afterEncrypt = CryptoJS.DES.encrypt('yourPassword', CryptoJS.enc.Utf8.parse(secretKey), {  mode: CryptoJS.mode.ECB,  padding: CryptoJS.pad.Pkcs7}).toString()// 解密var afterDecrypt = CryptoJS.DES.decrypt(afterEncrypt, CryptoJS.enc.Utf8.parse(secretKey), {  mode: CryptoJS.mode.ECB,  padding: CryptoJS.pad.Pkcs7}).toString(CryptoJS.enc.Utf8) AES加密 (使用crypto-js)javascript// 解密function findPass(username) {  const time = localStorage.lastLoginTime  if (time) {    const bytes = CryptoJS.AES.decrypt(localStorage.incantation, time)    var encodeText = bytes.toString(CryptoJS.enc.Utf8)    const arr = decodeURIComponent(encodeText).split(`--${time}--`)    if (arr[0] === username) {      return arr[1]    }  }  return null}// 加密function savePass({ username, password }) {  const time = new Date().toLocaleString()  const str = encodeURIComponent(`${username}--${time}--${password}`)  const ciphertext = CryptoJS.AES.encrypt(str, time)  localStorage.lastLoginTime = time  localStorag.incantation = ciphertext} 常用加密调用方式 哈希算法（Hash）加盐的原理:在计算哈希值前，向原始数据（如密码）添加随机数据（即“盐”）。这样，即使两个用户具有相同的原始密码，它们的最终哈希值也会因为加盐而不同。加盐使得预生成哈希值表（如彩虹表）变得无效，因为每个哈希值都需要独立计算。加盐的实践:1、生成随机盐:每次存储新密码时，生成一个新的随机盐。2、结合密码和盐:将盐与密码结合，然后一起进行哈希处理。3、存储盐和哈希值:将盐和结果哈希值一同存储在数据库中MD5算法javascript// 使用固定盐值的函数const salt = 'YourCustomSalt' // 随机盐值const passToSaltHash = (password) => {  const hash = crypto.createHash('md5')  return hash.update(password + salt).digest('hex')}const password = 'yourPassword'console.log(passToSaltHash(password)) // 输出加盐后的哈希值SHA算法javascriptconst crypto = require('crypto')// SHA-256加密示例const sha256Hash = (data) => {  return crypto.createHash('sha256').update(data).digest('hex')}const data = '示例数据'console.log('SHA-256加密: ' + sha256Hash(data))"
	},
	{
		"fileName": "类型转换规则",
		"fileType": "md",
		"path": "src/views/articles/js/类型转换规则.md",
		"category": "js",
		"id": "js-类型转换规则",
		"content": " 类型转换规则 Number(mix)1: 若为布尔值：true: 1 false: 02: 若为数字：返回其本身3: 若为null,则为04: 若为undefined 则为NaN5: 若为字符串：1）只包含数字，按十进制（忽略前导0）2）若为有效浮点数类型，则转为浮点数值（忽略前导0）3）若为空字符串，则转换为04）若包含非以上格式，则为NaN6: 若为对象，则先调用valueOf 再调用toString() 接着按照以上规则转换Number({}) = NaN{}.valueOf() = {};{}.toString() = [object Object] parseInt(string, radix)转换规则1）忽略字符串前的空格，直到遇到非空2）如果第一个遇到的字符不是数字或负号，则返回NaN3）若第一个字符是数字，则一直到非数字时停止4）(如果上步解析的结果以0开头，则将其当作八进制来解析；?目前似乎不再生效)如果以0x开头，则将其当作十六进制来解析5）如果指定radix参数，则以radix为基数进行解析 parseFloat(string)与parseInt基本一致区别1）字符串只有第一个小数点有效2）遇到整数时至返回整数而非浮点小数undefined 和 null 无 toString() 其余均有 Boolean(mix)除了 false、''、0、NaN、null、undefined会转换为false，其余均为true 隐式转换isNaN() 该方法会尝试使用Number() 来对参数进行转换 非数值 true 数值 false若进行对比时某一边为 数字时 会将两边都转化为数字进行对比若均为字符串时 实际上是**Unicode编码**转化为数字之后的比较'2' > '10' =====> trueNaN 与任何数据比较都是 false"
	},
	{
		"fileName": "设计模式",
		"fileType": "md",
		"path": "src/views/articles/js/设计模式.md",
		"category": "js",
		"id": "js-设计模式",
		"content": " 设计原则 1、单一职责原则（SRP: Single Responsibility Principle）> 一个对象或方法**只做一件事情**。应该把对象或方法划分成较小的粒度，如果一个方法承担了越多的职责，那么在需求变迁的过程中，这个方法需要被改写的可能性就越大。 2、开放/封闭原则（OCP: OpenClosed Principle）> 对拓展开放，对修改封闭> 对象（类、模块、函数等）应是**可扩展的，但是不可修改**的。当需要改变某个程序的功能或增加新功能时，应通过增加代码，拓展原有方法的方式，尽量避免修改源代码，防止影响原系统的稳定性。 3、里氏替换原则 （LSP: Liskov Substitution Principle）> 子类能覆盖父类> 父类能出现的地方子类就能出现子类应该能够完全替换任何父类能够出现的地方，并且经过替换后，不会让调用父类的客户程序从行为上有任何改变 4、接口隔离原则（ISP: Interface Segregation Principle）> 保持接口的单一独立> 接口尽量细化，同时接口中的方法尽量少客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。接口要尽量小，高内聚，定制服务，接口设计是有限度的。 5、依赖倒转原则（DIP: Dependency Inversion Principle）> 面向接口编程，依赖于抽象而不依赖于具体> 使用方只关注接口而不关注具体类的实现要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合 6、最少知识原则/迪米特法则（LKP: Least Knowledge Principle）> 一个对象应该对其他对象保持最少的了解一个对象应当尽可能少地与其他对象发生相互作用，如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系，可以转交给第三方（中介者）进行处理 设计模式- 创建型  - 单例模式  - 原型模式  - 工厂模式  - 抽象工厂模式  - 建造者模式- 结构型  - 适配器模式  - 装饰器模式  - 代理模式  - 外观模式  - 桥接模式  - 组合模式  - 享元模式- 行为型  - 观察者模式  - 迭代器模式  - 策略模式  - 模板方法模式  - 职责链模式  - 命令模式  - 备忘录模式  - 状态模式  - 访问者模式  - 中介者模式  - 解释器模式 工厂模式工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。javascriptclass Product {  constructor(name) {    this.name = name  }  init() {    console.log('init')  }  fun() {    console.log('fun')  }}class Factory {  create(name) {    return new Product(name)  }}// uselet factory = new Factory()let p = factory.create('p1')p.init()p.fun() 适用场景如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性 优点创建对象的过程可能很复杂，但我们只需要关心创建结果。构造函数和创建者分离, 符合“开闭原则”一个调用者想创建一个对象，只要知道其名称就可以了。扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 缺点添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度 什么时候不用当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。例子曾经我们熟悉的JQuery的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的jQuery对象javascriptclass jQuery {  constructor(selector) {    super(selector)  }  add() {}  // 此处省略若干API}window.$ = function (selector) {  return new jQuery(selector)} vue 的异步组件在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：javascriptVue.component('async-example', function (resolve, reject) {  setTimeout(function () {    // 向 `resolve` 回调传递组件定义    resolve({      template: '<div>I am async!</div>'    })  }, 1000)}) 单例模式一个类只有一个实例，并提供一个访问它的全局访问点。javascriptclass LoginForm {  constructor() {    this.state = 'hide'  }  show() {    if (this.state === 'show') {      alert('已经显示')      return    }    this.state = 'show'    console.log('登录框显示成功')  }  hide() {    if (this.state === 'hide') {      alert('已经隐藏')      return    }    this.state = 'hide'    console.log('登录框隐藏成功')  }}LoginForm.getInstance = (function () {  let instance  return function () {    if (!instance) {      instance = new LoginForm()    }    return instance  }})()let obj1 = LoginForm.getInstance()obj1.show()let obj2 = LoginForm.getInstance()obj2.hide()console.log(obj1 === obj2) 优点划分命名空间，减少全局变量增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护且只会实例化一次。简化了代码的调试和维护 缺点由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。 场景例子定义命名空间和实现分支型方法登录框vuex 和 redux中的store 适配器模式将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。javascriptclass Plug {  getName() {    return 'iphone充电头'  }}class Target {  constructor() {    this.plug = new Plug()  }  getName() {    return this.plug.getName() + ' 适配器Type-c充电头'  }}let target = new Target()target.getName() // iphone充电头 适配器转Type-c充电头 优点可以让任何两个没有关联的类一起运行。提高了类的复用。适配对象，适配库，适配数据 缺点额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善 场景整合第三方SDK封装旧接口javascript// 自己封装的ajax， 使用方式如下ajax({  url: '/getData',  type: 'Post',  dataType: 'json',  data: {    test: 111  }}).done(function () {})// 因为历史原因，代码中全都是：// $.ajax({....})// 做一层适配器var $ = {  ajax: function (options) {    return ajax(options)  }}vue的computedvue<template>  <div id=\"example\">    <p>Original message: \"{{ message }}\"</p>    <!-- Hello -->    <p>Computed reversed message: \"{{ reversedMessage }}\"</p>    <!-- olleH -->  </div></template><script type=\"text/javascript\">export default {  name: 'demo',  data() {    return {      message: 'Hello'    }  },  computed: {    reversedMessage: function () {      return this.message.split('').reverse().join('')    }  }}</script>原有data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式不同点适配器与代理模式相似适配器模式： 提供一个不同的接口（如不同版本的插头）代理模式： 提供一模一样的接口 装饰者模式动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象javascriptclass Cellphone {  create() {    console.log('生成一个手机')  }}class Decorator {  constructor(cellphone) {    this.cellphone = cellphone  }  create() {    this.cellphone.create()    this.createShell(cellphone)  }  createShell() {    console.log('生成手机壳')  }}// 测试代码let cellphone = new Cellphone()cellphone.create()console.log('------------')let dec = new Decorator(cellphone)dec.create() 场景例子比如现在有4 种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3 种配件。如果使用继承的方式来给每种自行车创建子类，则需要 4×3 = 12 个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3 个类ES7 Decorator 阮一峰core-decorators 优点装饰类和被装饰类都只关心自身的核心业务，实现了解耦。方便动态的扩展功能，且提供了比继承更多的灵活性。 缺点多层装饰比较复杂。常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问假设当A 在心情好的时候收到花，小明表白成功的几率有60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选择A 心情好的时候把花转交给A，代码如下：javascriptlet Flower = function () {}let xiaoming = {  sendFlower: function (target) {    let flower = new Flower()    target.receiveFlower(flower)  }}let B = {  receiveFlower: function (flower) {    A.listenGoodMood(function () {      A.receiveFlower(flower)    })  }}let A = {  receiveFlower: function (flower) {    console.log('收到花' + flower)  },  listenGoodMood: function (fn) {    setTimeout(function () {      fn()    }, 1000)  }}xiaoming.sendFlower(B) 场景HTML元 素事件代理javascript<ul id=\"ul\">  <li>1</li>  <li>2</li>  <li>3</li></ul><script>  let ul = document.querySelector('ul');  ul.addEventListener('click', event => {    console.log(event.target);  });</script>ES6 的 proxyjQuery.proxy()方法 优点代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则； 缺点处理请求速度可能有差别，非直接访问存在开销不同点装饰者模式实现上和代理模式类似装饰者模式： 扩展功能，原有功能不变且可直接使用代理模式： 显示原有功能，但是经过限制之后的 外观模式为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用兼容浏览器事件绑定javascriptlet addMyEvent = function (el, ev, fn) {  if (el.addEventListener) {    el.addEventListener(ev, fn, false)  } else if (el.attachEvent) {    el.attachEvent('on' + ev, fn)  } else {    el['on' + ev] = fn  }}封装接口javascriptlet myEvent = {  // ...  stop: (e) => {    e.stopPropagation()    e.preventDefault()  }} 场景设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。 优点减少系统相互依赖。提高灵活性。提高了安全性 缺点不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 观察者模式定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。发布 & 订阅一对多javascript// 主题 保存状态，状态变化之后触发所有观察者对象class Subject {  constructor() {    this.state = 0    this.observers = []  }  getState() {    return this.state  }  setState(state) {    this.state = state    this.notifyAllObservers()  }  notifyAllObservers() {    this.observers.forEach((observer) => {      observer.update()    })  }  attach(observer) {    this.observers.push(observer)  }}// 观察者class Observer {  constructor(name, subject) {    this.name = name    this.subject = subject    this.subject.attach(this)  }  update() {    console.log(`${this.name} update, state: ${this.subject.getState()}`)  }}// 测试let s = new Subject()let o1 = new Observer('o1', s)let o2 = new Observer('02', s)s.setState(12) 场景DOM事件javascriptdocument.body.addEventListener('click', function () {  console.log('hello world!')})document.body.click()vue 响应式 优点支持简单的广播通信，自动通知所有已经订阅过的对象目标对象与观察者之间的抽象耦合关系能单独扩展以及重用增加了灵活性观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。 缺点过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解 状态模式允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类javascript// 状态 （弱光、强光、关灯）class State {  constructor(state) {    this.state = state  }  handle(context) {    console.log(`this is ${this.state} light`)    context.setState(this)  }}class Context {  constructor() {    this.state = null  }  getState() {    return this.state  }  setState(state) {    this.state = state  }}// testlet context = new Context()let weak = new State('weak')let strong = new State('strong')let off = new State('off')// 弱光weak.handle(context)console.log(context.getState())// 强光strong.handle(context)console.log(context.getState())// 关闭off.handle(context)console.log(context.getState()) 场景一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态 优点定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便状态与状态间，行为与行为间彼此独立互不干扰用对象代替字符串来记录当前状态，使得状态的切换更加一目了然 缺点会在系统中定义许多状态类逻辑分散 迭代器模式提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。javascriptclass Iterator {  constructor(conatiner) {    this.list = conatiner.list    this.index = 0  }  next() {    if (this.hasNext()) {      return this.list[this.index++]    }    return null  }  hasNext() {    if (this.index >= this.list.length) {      return false    }    return true  }}class Container {  constructor(list) {    this.list = list  }  getIterator() {    return new Iterator(this)  }}// 测试代码let container = new Container([1, 2, 3, 4, 5])let iterator = container.getIterator()while (iterator.hasNext()) {  console.log(iterator.next())} 场景例子Array.prototype.forEachjQuery中的$.each()ES6 Iterator特点访问一个聚合对象的内容而无需暴露它的内部表示。为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作总结对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式 桥接模式桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。javascriptclass Color {  constructor(name) {    this.name = name  }}class Shape {  constructor(name, color) {    this.name = name    this.color = color  }  draw() {    console.log(`${this.color.name} ${this.name}`)  }}//测试let red = new Color('red')let yellow = new Color('yellow')let circle = new Shape('circle', red)circle.draw()let triangle = new Shape('triangle', yellow)triangle.draw() 优点有助于独立地管理各组成部分， 把抽象化与实现化解耦提高可扩充性 缺点大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少。 组合模式将对象组合成树形结构，以表示“整体-部分”的层次结构。通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性。javascriptclass TrainOrder {  create() {    console.log('创建火车票订单')  }}class HotelOrder {  create() {    console.log('创建酒店订单')  }}class TotalOrder {  constructor() {    this.orderList = []  }  addOrder(order) {    this.orderList.push(order)    return this  }  create() {    this.orderList.forEach((item) => {      item.create()    })    return this  }}// 可以在购票网站买车票同时也订房间let train = new TrainOrder()let hotel = new HotelOrder()let total = new TotalOrder()total.addOrder(train).addOrder(hotel).create() 场景表示对象-整体层次结构希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法） 缺点如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。 原型模式原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。javascriptclass Person {  constructor(name) {    this.name = name  }  getName() {    return this.name  }}class Student extends Person {  constructor(name) {    super(name)  }  sayHello() {    console.log(`Hello， My name is ${this.name}`)  }}let student = new Student('xiaoming')student.sayHello()原型模式，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升。 策略模式定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换html<html>  <head>    <title>策略模式-校验表单</title>    <meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\" />  </head>  <body>    <form id=\"registerForm\" method=\"post\" action=\"http://xxxx.com/api/register\">      用户名：<input type=\"text\" name=\"userName\" /> 密码：<input type=\"text\" name=\"password\" />      手机号码：<input type=\"text\" name=\"phoneNumber\" />      <button type=\"submit\">提交</button>    </form>    <script type=\"text/javascript\">      // 策略对象      const strategies = {        isNoEmpty: function (value, errorMsg) {          if (value === '') {            return errorMsg          }        },        isNoSpace: function (value, errorMsg) {          if (value.trim() === '') {            return errorMsg          }        },        minLength: function (value, length, errorMsg) {          if (value.trim().length < length) {            return errorMsg          }        },        maxLength: function (value, length, errorMsg) {          if (value.length > length) {            return errorMsg          }        },        isMobile: function (value, errorMsg) {          if (            !/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\\d{8}$/.test(              value            )          ) {            return errorMsg          }        }      }      // 验证类      class Validator {        constructor() {          this.cache = []        }        add(dom, rules) {          for (let i = 0, rule; (rule = rules[i++]); ) {            let strategyAry = rule.strategy.split(':')            let errorMsg = rule.errorMsg            this.cache.push(() => {              let strategy = strategyAry.shift()              strategyAry.unshift(dom.value)              strategyAry.push(errorMsg)              return strategies[strategy].apply(dom, strategyAry)            })          }        }        start() {          for (let i = 0, validatorFunc; (validatorFunc = this.cache[i++]); ) {            let errorMsg = validatorFunc()            if (errorMsg) {              return errorMsg            }          }        }      }      // 调用代码      let registerForm = document.getElementById('registerForm')      let validataFunc = function () {        let validator = new Validator()        validator.add(registerForm.userName, [          {            strategy: 'isNoEmpty',            errorMsg: '用户名不可为空'          },          {            strategy: 'isNoSpace',            errorMsg: '不允许以空白字符命名'          },          {            strategy: 'minLength:2',            errorMsg: '用户名长度不能小于2位'          }        ])        validator.add(registerForm.password, [          {            strategy: 'minLength:6',            errorMsg: '密码长度不能小于6位'          }        ])        validator.add(registerForm.phoneNumber, [          {            strategy: 'isMobile',            errorMsg: '请输入正确的手机号码格式'          }        ])        return validator.start()      }      registerForm.onsubmit = function () {        let errorMsg = validataFunc()        if (errorMsg) {          alert(errorMsg)          return false        }      }    </script>  </body></html> 场景例子如果在一个系统里面有许多类，它们之间的区别仅在于它们的'行为'，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。一个系统需要动态地在几种算法中选择一种。表单验证 优点利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，理解，易于扩展利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的代替方案 缺点会在程序中增加许多策略类或者策略对象要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy 享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式javascriptlet examCarNum = 0 // 驾考车总数/_ 驾考车对象 _/class ExamCar {constructor(carType) {examCarNum++this.carId = examCarNumthis.carType = carType ? '手动档' : '自动档'this.usingState = false // 是否正在使用}    /* 在本车上考试 */    examine(candidateId) {        return new Promise((resolve => {            this.usingState = true            console.log(`考生- ${ candidateId } 开始在${ this.carType }驾考车- ${ this.carId } 上考试`)            setTimeout(() => {                this.usingState = false                console.log(`%c考生- ${ candidateId } 在${ this.carType }驾考车- ${ this.carId } 上考试完毕`, 'color:f40')                resolve()                       // 0~2秒后考试完毕            }, Math.random() * 2000)        }))    }}/_ 手动档汽车对象池 _/ManualExamCarPool = {\\_pool: [], // 驾考车对象池\\_candidateQueue: [], // 考生队列    /* 注册考生 ID 列表 */    registCandidates(candidateList) {        candidateList.forEach(candidateId => this.registCandidate(candidateId))    },    /* 注册手动档考生 */    registCandidate(candidateId) {        const examCar = this.getManualExamCar()    // 找一个未被占用的手动档驾考车        if (examCar) {            examCar.examine(candidateId)           // 开始考试，考完了让队列中的下一个考生开始考试              .then(() => {                  const nextCandidateId = this._candidateQueue.length && this._candidateQueue.shift()                  nextCandidateId && this.registCandidate(nextCandidateId)              })        } else this._candidateQueue.push(candidateId)    },    /* 注册手动档车 */    initManualExamCar(manualExamCarNum) {        for (let i = 1; i <= manualExamCarNum; i++) {            this._pool.push(new ExamCar(true))        }    },    /* 获取状态为未被占用的手动档车 */    getManualExamCar() {        return this._pool.find(car => !car.usingState)    }}ManualExamCarPool.initManualExamCar(3) // 一共有3个驾考车ManualExamCarPool.registCandidates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) // 10个考生来考试 场景例子文件上传需要创建多个文件实例的时候如果一个应用程序使用了大量的对象，而这些大量的对象造成了很大的存储开销时就应该考虑使用享元模式 优点大大减少对象的创建，降低系统的内存，使效率提高。 缺点提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱 模板方法模式模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法和封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。javascriptclass Beverage {constructor({brewDrink, addCondiment}) {this.brewDrink = brewDrinkthis.addCondiment = addCondiment}/_ 烧开水，共用方法 _/boilWater() { console.log('水已经煮沸=== 共用') }/_ 倒杯子里，共用方法 _/pourCup() { console.log('倒进杯子里===共用') }/_ 模板方法 _/init() {this.boilWater()this.brewDrink()this.pourCup()this.addCondiment()}}/_ 咖啡 _/const coffee = new Beverage({/_ 冲泡咖啡，覆盖抽象方法 _/brewDrink: function() { console.log('冲泡咖啡') },/_ 加调味品，覆盖抽象方法 _/addCondiment: function() { console.log('加点奶和糖') }})coffee.init() 场景例子一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复 优点提取了公共代码部分，易于维护 缺点增加了系统复杂度，主要是增加了的抽象类和类间联系 职责链模式使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止javascript// 请假审批，需要组长审批、经理审批、总监审批class Action {  constructor(name) {    this.name = name    this.nextAction = null  }  setNextAction(action) {    this.nextAction = action  }  handle() {    console.log(`${this.name} 审批`)    if (this.nextAction != null) {      this.nextAction.handle()    }  }}let a1 = new Action('组长')let a2 = new Action('经理')let a3 = new Action('总监')a1.setNextAction(a2)a2.setNextAction(a3)a1.handle() 场景例子JS 中的事件冒泡作用域链原型链 优点降低耦合度。它将请求的发送者和接收者解耦。简化了对象。使得对象不需要知道链的结构增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任增加新的请求处理类很方便。 缺点不能保证某个请求一定会被链中的节点处理，这种情况可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能当面考虑，要避免过长的职责链到来的性能损耗。 命令模式将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。javascript// 接收者类class Receiver {  execute() {    console.log('接收者执行请求')  }}// 命令者class Command {  constructor(receiver) {    this.receiver = receiver  }  execute() {    console.log('命令')    this.receiver.execute()  }}// 触发者class Invoker {  constructor(command) {    this.command = command  }  invoke() {    console.log('开始')    this.command.execute()  }}// 仓库const warehouse = new Receiver()// 订单const order = new Command(warehouse)// 客户const client = new Invoker(order)client.invoke() 优点对命令进行封装，使命令易于扩展和修改命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行 缺点使用命令模式可能会导致某些系统有过多的具体命令类。 备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。javascript//备忘类class Memento {  constructor(content) {    this.content = content  }  getContent() {    return this.content  }}// 备忘列表class CareTaker {  constructor() {    this.list = []  }  add(memento) {    this.list.push(memento)  }  get(index) {    return this.list[index]  }}// 编辑器class Editor {  constructor() {    this.content = null  }  setContent(content) {    this.content = content  }  getContent() {    return this.content  }  saveContentToMemento() {    return new Memento(this.content)  }  getContentFromMemento(memento) {    this.content = memento.getContent()  }}//测试代码let editor = new Editor()let careTaker = new CareTaker()editor.setContent('111')editor.setContent('222')careTaker.add(editor.saveContentToMemento())editor.setContent('333')careTaker.add(editor.saveContentToMemento())editor.setContent('444')console.log(editor.getContent()) //444editor.getContentFromMemento(careTaker.get(1))console.log(editor.getContent()) //333editor.getContentFromMemento(careTaker.get(0))console.log(editor.getContent()) //222 场景例子分页控件撤销组件 优点给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 缺点消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 中介者模式解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系（类似于观察者模式，但是单向的，由中介者统一管理。）javascriptclass A {  constructor() {    this.number = 0  }  setNumber(num, m) {    this.number = num    if (m) {      m.setB()    }  }}class B {  constructor() {    this.number = 0  }  setNumber(num, m) {    this.number = num    if (m) {      m.setA()    }  }}class Mediator {  constructor(a, b) {    this.a = a    this.b = b  }  setA() {    let number = this.b.number    this.a.setNumber(number \\* 10)  }  setB() {    let number = this.a.number    this.b.setNumber(number / 10)  }}let a = new A()let b = new B()let m = new Mediator(a, b)a.setNumber(10, m)console.log(a.number, b.number)b.setNumber(10, m)console.log(a.number, b.number) 场景例子系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 优点使各对象之间耦合松散，而且可以独立地改变它们之间的交互中介者和对象一对多的关系取代了对象之间的网状多对多的关系如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码 缺点系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。 解释器模式给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。此例来自心谭博客javascriptclass Context {constructor() {this.\\_list = []; // 存放 终结符表达式this.\\_sum = 0; // 存放 非终结符表达式(运算结果)}    get sum() {      return this._sum;    }    set sum(newValue) {      this._sum = newValue;    }    add(expression) {      this._list.push(expression);    }    get list() {      return [...this._list];    }}class PlusExpression {interpret(context) {if (!(context instanceof Context)) {throw new Error(\"TypeError\");}context.sum = ++context.sum;}}class MinusExpression {interpret(context) {if (!(context instanceof Context)) {throw new Error(\"TypeError\");}context.sum = --context.sum;}}/** 以下是测试代码 **/const context = new Context();// 依次添加: 加法 | 加法 | 减法 表达式context.add(new PlusExpression());context.add(new PlusExpression());context.add(new MinusExpression());// 依次执行: 加法 | 加法 | 减法 表达式context.list.forEach(expression => expression.interpret(context));console.log(context.sum); 优点易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法 缺点执行效率较低，在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度慢对于复杂的文法比较难维护 访问者模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。javascript// 访问者class Visitor {  constructor() {}  visitConcreteElement(ConcreteElement) {    ConcreteElement.operation()  }}// 元素类class ConcreteElement {  constructor() {}  operation() {    console.log('ConcreteElement.operation invoked')  }  accept(visitor) {    visitor.visitConcreteElement(this)  }}// clientlet visitor = new Visitor()let element = new ConcreteElement()element.accept(visitor) 场景例子对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。 优点符合单一职责原则优秀的扩展性灵活性 缺点具体元素对访问者公布细节，违反了迪米特原则违反了依赖倒置原则，依赖了具体类，没有依赖抽象。具体元素变更比较困难[转自掘金](https://juejin.cn/post/6844904032826294286)"
	},
	{
		"fileName": "日常问题记录",
		"fileType": "md",
		"path": "src/views/articles/nodeJS/日常问题记录.md",
		"category": "nodeJS",
		"id": "nodeJS-日常问题记录",
		"content": " 日常记录 Express 热更新，可使用 “supervisor” Node 环境变量（.env）配置方法1、首先在项目中安装dotenvlinux  npm install dotenv2、在package.json scripts中将env文件名对应值写入：json\"scripts\": {    \"start\": \"export NODE_ENV=dev && supervisor ./bin/www\",  },3、并在目标文件中（此处则为./bin/www）配置dotenv的path参数 **（注意.env文件路径）**jsconst path = require('path')const dotenv = require('dotenv')dotenv.config({  path: path.resolve(__dirname, `../.env.\\${process\\.env\\.NODE_ENV}`)})"
	},
	{
		"fileName": "Http缓存",
		"fileType": "md",
		"path": "src/views/articles/other/Http缓存.md",
		"category": "other",
		"id": "other-Http缓存",
		"content": " Http缓存定义：HTTP缓存是客户端和服务端通信的一种缓存，可以将网页访问产生的数据缓存到内存或本地。所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息方式：HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略用途：合理利用可以提升资源重复利用率，减少网络带宽，降低服务器压力，提升客户端响应速度 强缓存定义：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。方法：强制缓存，在响应头由 Expires、Cache-Control 和 Pragma控制 Expires：HTTP1.0的属性属性，值为服务器返回的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。缺点是客户端和服务器时间不一致会导致命中误差 Cache-Control：HTTP1.1属性，优先级更高，可以组合使用多种指令，多个指令之间可以通过 “,” 分隔，以下为常用属性- no-store： 禁用缓存- no-cache：不使用强缓存，每次需向服务器验证缓存是否失效- public：表示可以被任何节点缓存，包括客户端和公共缓存服务器- private：表示该资源只能被客户端（浏览器）缓存- max-age=：max-age是距离请求发起的时间的秒数，给出了缓存的**相对时间**，单位为**秒**，即获得响应之后多少秒后过期，和Expires同时出现时，max-age优先级更高- s-maxage：对公共缓存服务器生效，表示该资源在公共服务器中缓存的相对时间。如果存在公共缓存服务器，浏览器缓存失效后，会先请求公共缓存服务器，公共缓存服务器失效后会重新请求资源服务器更新公共缓存服务器中的资源，然后返回给浏览器- must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证 Pragma- no-cache：效果和cache-control等no-cache一致。不缓存优先级Pragma > Cache-Control > Expires强缓存的资源存储位置(下表罗列了chrome 开发着工具中 network标签下资源请求表中信息)| 状态 Status | Network - Size | 含义 || ---- | -------------- | ---------------------------------------------------------------------------- || 200 | memory cache | 不请求网络资源，资源在内存，一般是脚本、字体、图片，浏览器关闭，数据将被释放 || 200 | disk cache | 请求网络资源，资源在磁盘，一般是css等，关闭数据还在 || 200 | 资源大小 | 从服务器下载最新资源 || 304 | 报文大小 | 请求服务端发现资源未更新，使用本地资源 | 协商缓存协商缓存是在强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存，如果使用，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源响应头中有两个字段标记规则- Last-Modified / If-Modified-Since  - Last-Modified是浏览器第一次请求资源，服务器响应头字段，是资源文件最后一次的更改时间(精确到秒)。  - 下一次发送请求时，请求头里的**If-Modified-Since**就是之前的**Last-Modified**  - 服务器更加最后修改时间判断命中，如果命中，http为304且不返回资源、不返回**Last-Modified**- Etag / If-None-Match：**Etag 的校验优先级高于 Last-Modified**  - Etag是加载资源时，服务器返回的响应头字段，是对资源的唯一标记，值是hash码。  - 浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到请求头里的**If-None-Match**里    服务器接受到**If-None-Match**的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。 启发式缓存缓存有效期由Expires和Cache-Control中的max-age来决定的，如果响应头中不存在用来确定强缓存时间的字段时，浏览器会触发启发式缓存，缓存有效期计算公式：**(date - last-modified ) \\* 10%，**取响应报头中 Date (_创建报文的日期时间_) 与 Last-Modified 值之差的百分之十作为缓存时间。只有在没有明确缓存策略时，会激活启发式缓存。所以要合理设置缓存，否则会因没有设置缓存时间等原因，导致内容缓存不刷新 不缓存方法 html文件设置meta；javascript<meta http-equiv=\"pragma\" content=\"no-cache\"><meta http-equiv=\"Cache-Control\" content=\"no-cache, must-revalidate\"><meta http-equiv=\"expires\" content=\"Wed, 26 Feb 1997 00:00:00 GMT\"> 服务端响应添加Cache-Control:no-cache,must-revalidate指令 修改请求头If-modified-since:0或If-none-match 请求url后增加时间戳 服务端设置Cache-Control:private指令，防止代理服务器缓存资源 相关问题 为什么同一个资源有时是from memory cache有时是from disk cacheChrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面 Cache-Control: max-age=0 和 no-cache有什么不同max-age=0和no-cache应该是从语义上不同。max-age=0是告诉客户端资源的缓存到期应该向服务器验证缓存的有效性。而no-cache则告诉客户端使用缓存前必须向服务器验证缓存的有效性。"
	},
	{
		"fileName": "前端安全问题汇总",
		"fileType": "md",
		"path": "src/views/articles/other/前端安全问题汇总.md",
		"category": "other",
		"id": "other-前端安全问题汇总",
		"content": " 前端安全问题汇总 XSS（跨站脚本攻击）XSS 漏洞是指攻击者在网页中注入恶意脚本，从而利用漏洞获取用户敏感信息或者进行恶意操作。 反射型XSS 存储型XSS DOM-Based XSS 防范 XSS 攻击的方法包括1、对输入数据进行过滤和转义2、使用 CSP（Content Security Policy，内容安全策略），白名单机制HTTP响应头中添加 Content-Security-Policy3、使用 HTTP-only 标识符，防止JS获取cookie CSRF（跨站请求伪造）CSRF 漏洞是指攻击者通过诱导用户访问恶意网站或者点击恶意链接，使得用户在已登录的网站上执行某些操作，从而实现攻击的目的。防范 CSRF 攻击的方法包括使用- token 验证- 检查 Referer  (Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的，服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等)- 使用验证码等 SQL 注入SQL 注入漏洞是指攻击者通过在输入框中输入恶意 SQL 语句，从而获取敏感数据。防范 SQL 注入漏洞的方法包括- 使用参数化查询- 限制输入长度- 过滤特殊字符等 文件上传漏洞文件上传漏洞是指攻击者通过上传恶意文件，在服务器上执行恶意代码或者获取服务器权限。防范文件上传漏洞的方法包括- 限制上传文件类型- 检查文件内容- 限制文件大小等。 点击劫持点击劫持是指攻击者通过将恶意网页置于透明的 iframe 中，覆盖在正常网页上，使得用户在不知情的情况下点击了恶意网页上的按钮或链接。防范点击劫持的方法包括- 使用 X-Frame-Options  (X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <frame>、<iframe>、<embed> 或者 <object> 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免点击劫持 (en-US)攻击。)  > Content-Security-Policy HTTP 响应头有一个 frame-ancestors 指令，支持这一指令的浏览器已经废弃了 X-Frame-Options 响应头。- 设置网页背景色等 其他[a标签target \\_blank的报错](https://fennngxiao.github.io//articles/mdPage/html-a标签target%20_blank的报错)"
	},
	{
		"fileName": "前端性能优化",
		"fileType": "md",
		"path": "src/views/articles/other/前端性能优化.md",
		"category": "other",
		"id": "other-前端性能优化",
		"content": " 性能优化 1. 减少 HTTP 请求一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程 2. 使用 HTTP2可通过chrome network工具protocol列信息查看请求类型详情 3. 使用服务端渲染 4. 静态资源使用 CDN 5. 将 CSS 放在文件头部，JavaScript 文件放在底部 6. 使用字体图标 iconfont 代替图片图标 7. 善用缓存，不重复加载相同的资源 8. 压缩文件 9. 图片优化 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码 11. 减少重绘重排 12. 使用事件委托 13. 注意程序的局部性时间局部性：在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。空间局部性 ：在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。 14. if-else 对比 switch 15. 查找表 16. 避免页面卡顿 17. 使用 requestAnimationFrame 来实现视觉变化 18. 使用 Web Workers 19. 使用位操作 20. 不要覆盖原生方法 21. 降低 CSS 选择器的复杂性 22. 使用 flexbox 而不是较早的布局模型 23. 使用 transform 和 opacity 属性更改来实现动画合理使用规则，避免过度优化性能优化主要分为两类：1、加载时优化2、运行时优化一个网站加载性能如何主要看白屏时间和首屏时间。白屏时间：指从输入网址，到页面开始显示内容的时间。首屏时间：指从输入网址，到页面完全渲染的时间。将以下脚本放在 </head> 前面就能获取白屏时间。html<script>  new Date() - performance.timing.navigationStart  // 通过 domLoading 和 navigationStart 也可以  performance.timing.domLoading - performance.timing.navigationStart</script>在 **window.onload** 事件里执行 **new Date() - performance.timing.navigationStart** 即可获取首屏时间。[转自掘金](https://juejin.cn/post/6892994632968306702?searchId=20240120192225B84DE14CBF09BBE6C5BE)"
	},
	{
		"fileName": "工具集",
		"fileType": "md",
		"path": "src/views/articles/other/工具集.md",
		"category": "other",
		"id": "other-工具集",
		"content": "[[toc]] 工具集 CSS类1.  Grabient: [https://www.grabient.com/](https://www.grabient.com/)   css渐变色配色及调试的网站   ![Unsplash](./imgs/design/WechatIMG179.png){{{width=\"400\" height=\"auto\"}}}2.  CSS clip-path: [https://bennettfeely.com/clippy/](https://bennettfeely.com/clippy/)   CSS clip-path在线调试编辑器，好用！   ![Unsplash](./imgs/design/WechatIMG198.png){{{width=\"400\" height=\"auto\"}}}3.  CSS cubic-bezier: [https://cubic-bezier.com](https://cubic-bezier.com)   CSS 贝塞尔曲线在线调试编辑器，带在线示例及调试对比，支持导入导出。   ![Unsplash](./imgs/design/WechatIMG199.png){{{width=\"400\" height=\"auto\"}}}4.  Adobe配色工具: [https://color.adobe.com/zh/create/color-wheel](https://color.adobe.com/zh/create/color-wheel)   ![Unsplash](./imgs/design/WechatIMG200.png){{{width=\"400\" height=\"auto\"}}}5.  Contrast Ratio: [https://www.siegemedia.com/contrast-ratio](https://www.siegemedia.com/contrast-ratio)   一个在线比对背景色及文字颜色合适与否的工具   ![Unsplash](./imgs/design/WechatIMG202.png){{{width=\"400\" height=\"auto\"}}}6.  渐变色配色方案: [https://uigradients.com/](https://uigradients.com/Dawn)   一个在线渐变色配色方案的工具   ![Unsplash](./imgs/design/WechatIMG203.png){{{width=\"400\" height=\"auto\"}}} 图片处理1.  TinyPNG: [https://tinypng.com/](https://tinypng.com/)   5mb以下著名的在线图片压缩工具，非常实用！   ![Unsplash](./imgs/design/WechatIMG204.png){{{width=\"400\" height=\"auto\"}}}2.  ImageRecycle: [https://www.imagerecycle.com/](https://www.imagerecycle.com/)   10mb以下的图可以用的在线图片压缩工具，5mb以上用不了Tiny就用这个   ![Unsplash](./imgs/design/WechatIMG207.png){{{width=\"400\" height=\"auto\"}}}3.  BgSub: [https://bgsub.cn/webapp/](https://bgsub.cn/webapp/)   实用的在线抠图工具   ![Unsplash](./imgs/design/WechatIMG205.png){{{width=\"400\" height=\"auto\"}}}4.  removebg: [https://www.remove.bg/zh/upload](https://www.remove.bg/zh/upload)   另一款实用的在线抠图工具   ![Unsplash](./imgs/design/WechatIMG206.png){{{width=\"400\" height=\"auto\"}}} 设计类1.  Open Peeps: [https://www.openpeeps.com/](https://www.openpeeps.com/)   一个可以在线编辑生成自己所需的各类卡通人物，可以用在设计或PPT当中   ![Unsplash](./imgs/design/WechatIMG201.png){{{width=\"400\" height=\"auto\"}}}2.  中国传统配色: [http://zhongguose.com/](http://zhongguose.com/yuhong)   ![Unsplash](./imgs/design/WechatIMG208.png){{{width=\"400\" height=\"auto\"}}}3.  日本传统配色: [https://nipponcolors.com](https://nipponcolors.com/momo)   ![Unsplash](./imgs/design/WechatIMG209.png){{{width=\"400\" height=\"auto\"}}}"
	},
	{
		"fileName": "浏览器渲染",
		"fileType": "md",
		"path": "src/views/articles/other/浏览器渲染.md",
		"category": "other",
		"id": "other-浏览器渲染",
		"content": " 当你在浏览器地址栏输入一个URL后回车，将会发生的事情？ 1、浏览器向DNS服务器查找输入URL对应的IP地址。我们输入的网址(域名)是IP地址的一个别名， 在一个DNS内，一个域名对应一个IP地址。域名系统(DNS) 的工作就是将域名与它的IP地址对应起来。DNS是分布式的，同时也是具有层级关系的。 2、DNS服务器返回网站的IP地址。递归寻找DNS服务器一个域名服务器虽然只记录一个小的子网内的主机名和IP地址， 但所有的域名服务器联合起来工作，就能将全网内的域名与它们的IP地址对应起来。 这也就意味着，如果一个域名服务器无法找到某个请求域名所对应的IP地址， 它就会向其它的域名服务器发出请求进行寻找。 3、浏览器根据IP地址与目标web服务器在80端口上建立TCP连接关于TCP协议 3.1、建立连接三次握手1:客户端的协议栈向服务端发送 SYN 包，并告诉服务端当前发送序列号 j（ISN），客户端进入 SYNC_SENT 状态；2:服务端的协议栈收到这个 SYN 包之后，检查 SYN 合法性，然后会创建一个半连接的对象，将其加入到内核的「 SYN 队列」。接着给客户端发送 SYN+ACK 包，确认序列号为 j+1，表示对 SYN 包 j 的确认，服务端序列号为 k（ISN），服务端进入 SYNC_RCVD 状态，这时处于半连接状态；3:客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回（或者监听的 socket 有读事件），表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务端的 SYN 包进行应答，确认序号为 k+1；4:当服务器端收到这个 ACK 包的时候，从「 SYN 队列」取出对应的半连接对象，然后创建一个新的全连接对象放入到「 Accept 队列」，这个时候服务端到客户端的单向连接也建立成功，服务端也进入 ESTABLISHED 状态；服务端调用 accept 函数，从「Accept 队列」中取出全连接对象，创建一个新的用于双向通信的 sockfd。第三次握手是可以携带数据的，前两次握手是不可以携带数据的。 3.2、关闭连接四次挥手1:「主动方」想要关闭连接，会发送一个 FIN 报文，序号 m，之后「主动方」进入 FIN_WAIT_1 状态，仅仅表示「主动方」不再发送数据了但是还能接收数据；2:「被动方」收到 FIN 报文后，就向「主动方」发送 ACK m + 1 应答报文，并向接收缓冲区写入一个文件结束符 EOF，排在未读数据之后，然后「被动方」进入 CLOSE_WAIT 状态；3:「主动方」收到「被动方」的 ACK 应答报文之后进入 FIN_WAIT_2 状态；4:「被动方」把数据发送完并且调用 read 函数读到 EOF 后，调用 close 函数，也向「主动方」发送 FIN 报文，序号 n，然后「被动方」进入 LAST_ACK 状态。如果发现服务器有大量 CLOSE_WAIT 状态的连接，需要排查代码中是否有 bug 导致 read 到 EOF 后没有调用 close 函数；5:「主动方」收到「被动方」的 FIN 报文后，回一个 ACK n + 1 应答报文，然后进入 TIME_WAIT 状态；6:「被动方」收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此「被动方」已经完成连接的关闭；7:「主动方」在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此「主动方」也完成连接的关闭。从上面过程可知，「被动方」通常需要等待发送和处理完数据，所以「被动方」的 FIN 和 ACK 一般都会分开发送，因此是需要四次挥手。但是在特定情况下（「被动方」在收到第一次握手后，没有要处理的数据了），四次挥手是可以变成三次挥手的。「被动方」才有 CLOSE_WAIT 状态，如果「被动方」因为代码 bug 没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，也就无法使得 CLOSE_WAIT 状态转变为 LAST_ACK 状态。TCP 的连接信息是由内核维护的，当进程崩溃后，内核回收该进程的所有 TCP 连接，内核会与对端完成四次挥手。 4、浏览器获取请求页面的html代码。4.1:向目标服务器发送http请求4.2:web服务器接收请求后处理4.3:web服务器返回相应的结果【无效、重定向、正确页面等】4.5:浏览器接收返回的http内容 5、浏览器在显示窗口内渲染HTML。5.1:开始解析html文件，当然是自上而下，先是头部，后是body5.2:当解析到头部css外部链接时，同步去下载，如果遇到外部js链接也是下载【 不过js链接不建议放在头部，因为耽误页面第一展现时间 】5.3:接着解析body部分，边解析边开始生成对应的DOM树，同时等待css文件下载5.4:一旦css文件下载完毕，那么就同步去用已经生成的DOM节点+CSS去生成渲染树5.5:渲染树一旦有结构模型了，接着就会同步去计算渲染树节点的布局位置5.6:一旦计算出来渲染的坐标后，又同步去开始渲染5.7:进行过程中如果遇到图片则跳过去渲染下面内容，等待图片下载成功后会返回来在渲染原来图片的位置5.8:如果渲染过程中出现js代码调整DOM树机构的情况，也会再次重新来过，从修改DOM那步开始5.9:最终所有节点和资源都会渲染完成5.10:渲染完成后开始页面的onload事件5.11:自此整个页面load完成 6、窗口关闭时，浏览器终止与服务器的连接。"
	},
	{
		"fileName": "线程竞争",
		"fileType": "md",
		"path": "src/views/articles/other/线程竞争.md",
		"category": "other",
		"id": "other-线程竞争",
		"content": " 线程竞争（Thread Contention） 简介也称为竞争条件（Race Condition），是指多个线程在同时访问和修改共享资源时，可能导致不可预期的行为或错误。由于线程调度的不可预测性，这些线程在运行时的执行顺序可能会有所不同，从而导致数据的不一致性或其他问题。 线程竞争的典型问题- **数据不一致性**：多个线程同时读写共享数据，可能导致数据状态不一致。例如，两个线程同时修改一个计数器变量，最终结果可能不是预期的增量值。- **死锁（Deadlock）**：多个线程互相等待对方释放资源，导致程序无法继续执行。- **活锁（Livelock）**：多个线程频繁改变状态或相互让步，导致系统无法前进，但线程本身并未阻塞。- **资源饥饿（Resource Starvation）**：某些线程长时间无法获得所需资源，导致其无法执行。 线程竞争的解决方法- **锁机制**：使用**互斥锁（Mutex）**、**读写锁（Read-Write Lock）**等同步原语来确保同一时刻只有一个线程能访问共享资源。例如，Java中的synchronized关键字和ReentrantLock类。- **原子操作**：确保某些操作在执行过程中不会被中断。许多编程语言提供了原子类，如Java中的AtomicInteger。- **线程局部存储（Thread Local Storage）**：为每个线程提供独立的存储，避免共享数据。- **不可变对象**：使用不可变对象，避免对象状态在创建后被修改。- **消息传递模型**：使用消息传递而非共享内存，避免直接共享数据。例如，使用队列（Queue）在生产者-消费者模式中传递消息。 示例假设我们有一个简单的计数器程序，两个线程同时对其进行递增操作：javapublic class Counter {    private int count = 0;    public void increment() {        count++;    }    public int getCount() {        return count;    }    public static void main(String[] args) {        Counter counter = new Counter();        Runnable task = () -> {            for (int i = 0; i < 1000; i++) {                counter.increment();            }        };        Thread thread1 = new Thread(task);        Thread thread2 = new Thread(task);        thread1.start();        thread2.start();        try {            thread1.join();            thread2.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(\"Final count: \" + counter.getCount());    }}在这个例子中，由于increment方法不是线程安全的，最终的计数结果可能不是预期的2000。解决办法，使用同步javapublic class Counter {    private int count = 0;    public synchronized void increment() {        count++;    }    public int getCount() {        return count;    }}通过将`increment`方法声明为`synchronized`，确保每次只有一个线程能执行该方法，从而避免线程竞争导致的数据不一致问题。线程竞争是并发编程中的常见问题，理解并合理使用同步机制和并发工具可以有效避免相关问题，确保程序的正确性和稳定性。"
	},
	{
		"fileName": "软件开发模型",
		"fileType": "md",
		"path": "src/views/articles/other/软件开发模型.md",
		"category": "other",
		"id": "other-软件开发模型",
		"content": " 软件开发模型 一、边做边改模型 （Build-and-Fix Model）在这种模型中，既没有规格说明，也没有软件设计，软件随着客户的需要一次又一次地不断被修改。在这个模型中，开发人员拿到项目立即根据需求编写程序，调试通过后生成软件的第一个版本。在提供给用户使用后，如果程序出现错误，或者用户提出新的要求，开发人员重新修改代码，直到用户满意为止这是一种类似作坊的开发方式，对编写几百行的小程序来说还不错，但这种方法对任何规模的开发来说都是不能令人满意的，其主要问题在于：（1） 缺少规划和设计环节，软件的结构随着不断的修改越来越糟，导致无法继续修改；（2）忽略需求环节，给软件开发带来很大的风险；（3）没有考虑测试和程序的可维护性，也没有任何文档，软件的维护十分困难 二、瀑布模型（Waterfall Model）被广泛采用的开发模型，包括三个大阶段，并将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。1、定义阶段- 制定计划- 需求分析2、开发阶段- 软件设计- 程序编码- 软件测试3、维护阶段- 运行维护在瀑布模型中，软件开发的各项活动严格按照线性方式进行，当前活动接受上一项活动的工作结果，实施完成所需的工作内容。当前活动的工作结果需要进行验证，如果验证通过，则该结果作为下一项活动的输入，继续进行下一项活动，否则返回修改。瀑布模型强调文档的作用，并要求每个阶段都要仔细验证缺陷：这种模型的线性过程太理想化，已不再适合现代的软件开发模式，其主要问题在于：（1） 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；（2） 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；（3） 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果 三、快速原型模型（Rapid Prototype Model）快速原型模型的第一步是建造一个快速原型，实现客户或未来的用户与系统的交互，用户或客户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足客户的要求，开发人员可以确定客户的真正需求是什么；第二步则在第一步的基础上开发客户满意的软件产品快速原型的关键在于尽可能快速地建造出软件原型，一旦确定了客户的真正需求，所建造的原型将被丢弃。因此，原型系统的内部结构并不重要，重要的是必须迅速建立原型，随之迅速修改原型，以反映客户的需求。 四、增量模型（Incremental Model）演化模型在增量模型中，软件被作为一系列的增量构件来设计、实现、集成和测试，每一个构件是由多种相互作用的模块所形成的提供特定功能的代码片段构成增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险缺陷：（1） 由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。（2） 在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。在使用增量模型时，第一个增量往往是实现基本需求的核心产品。核心产品交付用户使用后，经过评价形成下一个增量的开发计划，它包括对核心产品的修改和一些新功能的发布。这个过程在每个增量发布后不断重复，直到产生最终的完善产品。 五、敏捷开发模型（Agile-Development-Model）敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态敏捷开发小组主要的工作方式：（1）作为一个整体工作；（2）按短迭代周期工作；（3）每次迭代交付一些成果，关注业务优先级，检查与调整。敏捷开发的4个核心思想：（1）强调面对面的沟通，人和人的相互交流胜于任何流程和工具（2）把精力集中在可执行的程序上，可以运行的产品胜于编制综合性文档，强调了原型、模型、demo等的重要性（3）团队合作和团队激励，合作胜于谈判，敏捷开发能将需求、开发、测试等全部团队成员融合成一个整体，大家都是一条线上的蚂蚱（4）超强的适应能力，适应变化胜于按部就班，敏捷开发的特点就是快速敏捷软件开发要注意项目规模，规模增长，团队交流成本就上去了，因此敏捷软件开发暂时适合不是特别大的团队开发，比较适合一个组的团队使用。 六、螺旋模型（Spiral Model）它是瀑布模型和快速原型模型的结合，“螺旋模型”的核心就在于不需要在刚开始的时候就把所有事情都定义的清清楚楚。轻松上阵，定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。如此不断轮回重复，直到得到客户满意的最终产品。通常由四个阶段组成- 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；- 风险分析: 分析评估所选方案，考虑如何识别和消除风险；- 实施工程；实施软件开发和验证；- 客户评估;评价开发工作，提出修正建议，制定下一步计划； 七、迭代模型 （RUP模型）也被称作迭代增量式开发或迭代进化式开发，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。- 每次只设计和实现这个产品的一部分；- 逐步逐步完成的方法叫迭代开发；- 每次设计和实现一个阶段叫做一个迭代；优点：（1）降低了在一个增量上的开支风险。如果开发人员重复某个迭代，那么损失只是这一个开发有误的迭代的花费。（2）降低了产品无法按照既定进度进入市场的风险。通过在开发早期就确定风险，可以尽早来解决而不至于在开发后期匆匆忙忙。（3）加快了整个开发工作的进度。因为开发人员清楚问题的焦点所在，他们的工作会更有效率。（4）复用性更高，由于用户的需求并不能在一开始就作出完全的界定，它们通常是在后续阶段中不断细化的。因此，迭代过程这种模式使适应需求的变化会更容易"
	}
]